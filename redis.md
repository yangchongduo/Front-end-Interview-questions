
#### redis消息 list
- . publish  将数据写入到一个list or sorted list 队列,写完成后开始给终端广播消息,告诉大家,有新的数据等待处理,这个时候,谁能pop到数据,就是谁处理,这个操作是原子性的,也就是说不会被重复处理.   
- . 使用阻塞模式, redis提供了blpop brpop这种操作,也就是一直阻塞一个队列,直到有数据来. 这种模式保证了数据的原子性,而且使应用程序可以支持分布式多台机器部署.  
- 当链表为空的时候，brpop是阻塞的，等待超时时间到或者另一个客户端lpush一个元素  
- 可以实现分布式和共享  
- Redis的PUSH/POP机制，利用的Redis的列表(lists)数据结构。比较好的使用模式是，生产者lpush消息，消费者brpop消息，并设定超时时间，可以减少redis的压力。这种方案相对于第一种方案是数据可靠性提高了，只有在Redis宕机且数据没有持久化的情况下丢失数据，可以根据业务通过AOF和缩短持久化间隔来保证很高的可靠性，而且也可以通过多个client来提高消费速度。但相对于专业的消息队列来说，该方案消息的状态过于简单(没有状态)，且没有ack机制，消息取出后消费失败依赖于client记录日志或者重新push到队列里面。  

#### redis场景 很多东西都可以放在redis里面  
>1 不经常变得数据，放在redis里面，比如首页不变，我们可以放在redis里面，个人中心也设置redis缓存，这样就不用查询数据库了，查询完之后还得需要处理，这样不用查询，不用组装       
>2 token更好，请查看auth.png      
>3 根据sku_id的时候，得到key，然后到redis里面获取，取值。有直接返回，没有就到数据库里面取值。    
>4 这个例子演示了用 Redis 的 list 命令实现一个先入先出队列(FIFO)。现实中注册 系统会用到 FIFO:当涌入的注册请求数量超过了实时处理的能力时，注册信息会被 转移到队列中去，以便在主程序外处理。注册请求会按照接收的顺序处理，但主程 序不会因为需要处理真正的创建记录和介绍工作(如发送欢迎邮件)而变慢   

#### redis
------------------------------
```
http://www.aboutyun.com/thread-9223-1-1.html
```
>1 启动redis  redis-server  
>2 连接本地的redis redis-cli    ping出现PONG 就对了  
>3 查看所有的  keys *    
>4 删除一个key  del key  
>5 代码值和赋值之后，问题：数据的位置 从配置文件中可以查出来  
>6 mongo 安装 很多项目是基于mongo 和 redis的  
>7 需要具体看到浏览器中有cookie  
>8 redis-cli  flushall 清除缓存
