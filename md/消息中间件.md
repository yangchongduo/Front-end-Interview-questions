### [消息队列](http://www.cnblogs.com/stopfalling/p/5375492.html) 详情请查看 【node即学即用 第二部分 6.4 】  
```
之前，我们举了邮递员的例子来描述 Node 的事件循环架构。如果邮递员碰到哪家 关了门，
他就无法继续投递信件了。想象一下，如果有一名好心的老门卫能够把门 打开，让邮递员通过呢?但是门卫已经上了年纪，
\且因为服务多年而身体虚弱，他 需要多花点时间才能清理道路，因此这段时间内邮递员暂时无法继续投递信件。
这就类似堵塞的进程，但这种状况不会一直持续。最终，门卫会把门打开，然后邮 递员又能继续他的业务了。
如果邮递员到达的每一个屋子都有类似的开门进程，会 把整个通道都拖慢。在 Node 程序里，这类堵塞将严重降低系统性能。  
在计算机领域，造成类似情况的原因很多，可能是因为在注册过程中需要发送用户 邮件，需要对用户输入进行大量的数学运算，
或者是某个 任务需要花费的时间超过 了用户期望的等待时间，等等。Node 的事件驱动设计可用来应对大多数情况，
它采 用的是异步函数和回调的方法。但是如果一个事件特别“重”的话，就不应该放在 Node 内部处理。Node 应该只负责快速运算和处理返回的结果。  
以一个普通的用户注册流程为例。当用户自己注册时，应用程序会在数据库中保存 一条新的记录，并发送邮件给该用户。
它也许还会记录下注册过程中的一些统计数 据，比如整个过程包括了几个步骤、花费了多少时间。如果用户刚在你的网页上点 击提交按钮，
系统就马上处理那么多的操作，其实并没有太大意义。比如，发送邮 件的流程也许需要花费几秒钟(如果你运气不佳，要花上几分钟)来完成，
数据库 调用可以等到用户受到欢迎之后再进行操作，统计数据可以从程序的主逻辑独立出 去处理。这样的情况下，你可以选择生成一条消息，
来通知程序的其他部分有新用 户注册了，这样的程序也可能是完全运行在另外一台服务器上的。这就是我们所称 的发布 - 订阅模型(publish-subscribe pattern)。  
再假设你有一个集群的机器运行了 Node.js 程序。当一台新机器要加入到集群的时 候，它发出一条信息来请求配置信息。
配置服务器返回的信息包含了新机器整合到 集群中所需要的配置信息列表，这称为请求 - 回复模型(request-reply pattern)。  
消息队列允许程序员发布事件然后继续其他操作，通过进程间通信频道，提高了并 发处理的效率，并实现了更高的扩展性。  
```
